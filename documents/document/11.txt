# Foundry

This guide explains how to use Foundry with FHEVM for developing smart contracts.

While a Foundry template is currently in development, we strongly recommend using the [Hardhat template](https://docs.zama.org/protocol/solidity-guides/getting-started/setup)) for now, as it provides a fully tested and supported development environment for FHEVM smart contracts.

However, you could still use Foundry with the mocked version of the FHEVM, but please be aware that this approach is **NOT** recommended, since the mocked version is not fully equivalent to the real FHEVM node's implementation (see warning in hardhat). In order to do this, you will need to rename your `FHE.sol` imports from `@fhevm/solidity/lib/FHE.sol` to `fhevm/mocks/FHE.sol` in your solidity source files.


# HCU

This guide explains how to use Fully Homomorphic Encryption (FHE) operations in your smart contracts on FHEVM. Understanding HCU is critical for designing efficient confidential smart contracts.

## Overview

FHE operations in FHEVM are computationally intensive compared to standard Ethereum operations, as they require complex mathematical computations to maintain privacy and security. To manage computational load and prevent potential denial-of-service attacks, FHEVM implements a metering system called **Homomorphic Complexity Units ("HCU")**.

To represent this complexity, we introduced the **Homomorphic Complexity Unit ("HCU")**. In Solidity, each FHE operation consumes a set amount of HCU based on the operational computational complexity for hardware computation. Since FHE transactions are symbolic, this helps preventing resource exhaustion outside of the blockchain.

To do so, there is a contract named `HCULimit`, which monitors HCU consumption for each transaction and enforces two key limits:

* **Sequential homomorphic operations depth limit per transaction**: Controls HCU usage for operations that must be processed in order.
* **Global homomorphic operations complexity per transaction**: Controls HCU usage for operations that can be processed in parallel.

If either limit is exceeded, the transaction will revert.

## HCU limit

The current devnet has an HCU limit of **20,000,000** per transaction and an HCU depth limit of **5,000,000** per transaction. If either HCU limit is exceeded, the transaction will revert.

To resolve this, you must do one of the following:

* Refactor your code to reduce the number of FHE operations in your transaction.
* Split your FHE operations across multiple independent transactions.

## HCU costs for common operations

### Boolean operations (`ebool`)

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `and`         | 22,000       | 25,000           |
| `or`          | 22,000       | 24,000           |
| `xor`         | 2,000        | 22,000           |
| `not`         | -            | 2                |
| `select`      | -            | 55,000           |
| `randEbool`   | -            | 19,000           |

***

### Unsigned integer operations

HCU increase with the bit-width of the encrypted integer type. Below are the detailed costs for various operations on encrypted types.

#### **8-bit Encrypted integers (`euint8`)**

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `add`         | 84,000       | 88,000           |
| `sub`         | 84,000       | 91,000           |
| `mul`         | 122,000      | 150,000          |
| `div`         | 210,000      | -                |
| `rem`         | 440,000      | -                |
| `and`         | 31,000       | 31,000           |
| `or`          | 30,000       | 30,000           |
| `xor`         | 31,000       | 31,000           |
| `shr`         | 32,000       | 91,000           |
| `shl`         | 32,000       | 92,000           |
| `rotr`        | 31,000       | 93,000           |
| `rotl`        | 31,000       | 91,000           |
| `eq`          | 55,000       | 55,000           |
| `ne`          | 55,000       | 55,000           |
| `ge`          | 52,000       | 63,000           |
| `gt`          | 52,000       | 59,000           |
| `le`          | 58,000       | 58,000           |
| `lt`          | 52,000       | 59,000           |
| `min`         | 84,000       | 119,000          |
| `max`         | 89,000       | 121,000          |
| `neg`         | -            | 79,000           |
| `not`         | -            | 9                |
| `select`      | -            | 55,000           |
| `randEuint8`  | -            | 23,000           |

#### **16-bit Encrypted integers (`euint16`)**

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `add`         | 93,000       | 93,000           |
| `sub`         | 93,000       | 93,000           |
| `mul`         | 193,000      | 222,000          |
| `div`         | 302,000      | -                |
| `rem`         | 580,000      | -                |
| `and`         | 31,000       | 31,000           |
| `or`          | 30,000       | 31,000           |
| `xor`         | 31,000       | 31,000           |
| `shr`         | 32,000       | 123,000          |
| `shl`         | 32,000       | 125,000          |
| `rotr`        | 31,000       | 125,000          |
| `rotl`        | 31,000       | 125,000          |
| `eq`          | 55,000       | 83,000           |
| `ne`          | 55,000       | 83,000           |
| `ge`          | 55,000       | 84,000           |
| `gt`          | 55,000       | 84,000           |
| `le`          | 58,000       | 83,000           |
| `lt`          | 58,000       | 84,000           |
| `min`         | 88,000       | 146,000          |
| `max`         | 89,000       | 145,000          |
| `neg`         | -            | 93,000           |
| `not`         | -            | 16               |
| `select`      | -            | 55,000           |
| `randEuint16` | -            | 23,000           |

#### **32-bit Encrypted Integers (`euint32`)**

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `add`         | 95,000       | 125,000          |
| `sub`         | 95,000       | 125,000          |
| `mul`         | 265,000      | 328,000          |
| `div`         | 438,000      | -                |
| `rem`         | 792,000      | -                |
| `and`         | 32,000       | 32,000           |
| `or`          | 32,000       | 32,000           |
| `xor`         | 32,000       | 32,000           |
| `shr`         | 32,000       | 163,000          |
| `shl`         | 32,000       | 162,000          |
| `rotr`        | 32,000       | 160,000          |
| `rotl`        | 32,000       | 163,000          |
| `eq`          | 82,000       | 86,000           |
| `ne`          | 83,000       | 85,000           |
| `ge`          | 84,000       | 118,000          |
| `gt`          | 84,000       | 118,000          |
| `le`          | 84,000       | 117,000          |
| `lt`          | 83,000       | 117,000          |
| `min`         | 117,000      | 182,000          |
| `max`         | 117,000      | 180,000          |
| `neg`         | -            | 131,000          |
| `not`         | -            | 32               |
| `select`      | -            | 55,000           |
| `randEuint32` | -            | 24,000           |

#### **64-bit Encrypted integers (`euint64`)**

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `add`         | 133,000      | 162,000          |
| `sub`         | 133,000      | 162,000          |
| `mul`         | 365,000      | 596,000          |
| `div`         | 715,000      | -                |
| `rem`         | 1,153,000    | -                |
| `and`         | 34,000       | 34,000           |
| `or`          | 34,000       | 34,000           |
| `xor`         | 34,000       | 34,000           |
| `shr`         | 34,000       | 209,000          |
| `shl`         | 34,000       | 208,000          |
| `rotr`        | 34,000       | 209,000          |
| `rotl`        | 34,000       | 209,000          |
| `eq`          | 83,000       | 120,000          |
| `ne`          | 84,000       | 118,000          |
| `ge`          | 116,000      | 152,000          |
| `gt`          | 117,000      | 152,000          |
| `le`          | 119,000      | 149,000          |
| `lt`          | 118,000      | 146,000          |
| `min`         | 150,000      | 219,000          |
| `max`         | 149,000      | 218,000          |
| `neg`         | -            | 131,000          |
| `not`         | -            | 63               |
| `select`      | -            | 55,000           |
| `randEuint64` | -            | 24,000           |

#### **128-bit Encrypted integers (`euint128`)**

| Function name  | HCU (scalar) | HCU (non-scalar) |
| -------------- | ------------ | ---------------- |
| `add`          | 172,000      | 259,000          |
| `sub`          | 172,000      | 260,000          |
| `mul`          | 696,000      | 1,686,000        |
| `div`          | 1,225,000    | -                |
| `rem`          | 1,943,000    | -                |
| `and`          | 37,000       | 37,000           |
| `or`           | 37,000       | 37,000           |
| `xor`          | 37,000       | 37,000           |
| `shr`          | 37,000       | 272,000          |
| `shl`          | 37,000       | 272,000          |
| `rotr`         | 37,000       | 283,000          |
| `rotl`         | 37,000       | 278,000          |
| `eq`           | 117,000      | 122,000          |
| `ne`           | 117,000      | 122,000          |
| `ge`           | 149,000      | 210,000          |
| `gt`           | 150,000      | 218,000          |
| `le`           | 150,000      | 218,000          |
| `lt`           | 149,000      | 215,000          |
| `min`          | 186,000      | 289,000          |
| `max`          | 180,000      | 290,000          |
| `neg`          | -            | 168,000          |
| `not`          | -            | 130              |
| `select`       | -            | 57,000           |
| `randEuint128` | -            | 25,000           |

#### **256-bit Encrypted integers (`euint256`)**

| Function name  | HCU (scalar) | HCU (non-scalar) |
| -------------- | ------------ | ---------------- |
| `and`          | 38,000       | 38,000           |
| `or`           | 38,000       | 38,000           |
| `xor`          | 39,000       | 39,000           |
| `shr`          | 38,000       | 369,000          |
| `shl`          | 39,000       | 378,000          |
| `rotr`         | 40,000       | 375,000          |
| `rotl`         | 38,000       | 378,000          |
| `eq`           | 118,000      | 152,000          |
| `ne`           | 117,000      | 150,000          |
| `neg`          | -            | 269,000          |
| `not`          | -            | 130              |
| `select`       | -            | 108,000          |
| `randEuint256` | -            | 30,000           |

#### **Encrypted addresses (`euint160`)**

When using `eaddress` (internally represented as `euint160`), the HCU costs for equality and inequality checks and select are as follows:

| Function name | HCU (scalar) | HCU (non-scalar) |
| ------------- | ------------ | ---------------- |
| `eq`          | 115,000      | 125,000          |
| `ne`          | 115,000      | 124,000          |
| `select`      | -            | 83,000           |

## Additional Operations

| Function name    | HCU           |
| ---------------- | ------------- |
| `cast`           | 32            |
| `trivialEncrypt` | 32            |
| `randBounded`    | 23,000-30,000 |



# Migrate to v0.9

FHEVM v0.9 introduces major architectural changes, including:

* Removal of the Zama Oracle
* Introduction of a self-relaying public decryption workflow
* Unified `ZamaEthereumConfig` replacing `SepoliaConfig`

This guide explains what changed and how to migrate your project smoothly.

## What Changed in FHEVM v0.9?

Before diving into migration steps, it’s important to understand the main breaking change: public decryption is no longer handled by a Zama Oracle, but by your dApp’s off-chain logic.

### FHEVM v0.8 Oracle-Based Decryption

In FHEVM v0.8, the decryption process relies on a trusted **Oracle** to relay the decryption request and proof between the dApp and the Zama Key Management System (KMS). This approach abstracts the complexity but introduces an external dependency.

**Decryption Steps:**

| Step   | Component                    | Action                                                                                                           |
| ------ | ---------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **1.** | **dApp (Solidity)**          | Calls `FHE.requestDecryption()` to signal a need for clear data.                                                 |
| **2.** | **Oracle**                   | Listens for the on-chain decryption request event.                                                               |
| **3.** | **Oracle (Off-chain)**       | Performs the `publicDecryption` with the Zama KMS, retrieving the **clear values** and the **decryption proof**. |
| **4.** | **Oracle**                   | Calls the user-specified dApp **callback Solidity function** with the clear values and the associated proof.     |
| **5.** | **dApp (Solidity Callback)** | Calls `FHE.verifySignatures()` to verify the authenticity of the clear values using the provided proof.          |

> **Key takeaway for v0.8:** The Oracle is the trusted intermediary responsible for performing the off-chain decryption and submitting the result back to the dApp contract.

### FHEVM v0.9 Self-Relaying Decryption & dApp Responsibility

The FHEVM v0.9 architecture shifts to a **self-relaying model**, empowering the dApp client (the user) to execute the off-chain decryption and re-submission. This decentralizes the process and removes the dependency on a general-purpose Oracle.

**Example Scenario: Checking a Player's Encrypted Score**

Consider a **Game contract** where Alice's final score is stored encrypted on-chain. Alice needs to prove her clear score to claim a reward.

| Step   | Component                    | Action                                                                                                                                                                                  |
| ------ | ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1.** | **Game Contract (Solidity)** | An on-chain function is called to make Alice's encrypted score **publicly decryptable**.                                                                                                |
| **2.** | **Alice (Client/Off-chain)** | Alice fetches the publicly decryptable encrypted score from the Game contract.                                                                                                          |
| **3.** | **Alice (Client/Off-chain)** | Alice or any third-party service uses the **`@zama-fhe/relayer-sdk`** to call the off-chain `publicDecrypt` function. This returns the clear score value and a **proof of decryption**. |
| **4.** | **Alice (Client/On-chain)**  | Alice calls a function on the **Game contract** with the decrypted clear score and the proof.                                                                                           |
| **5.** | **Game Contract (Solidity)** | The contract calls `FHE.verifySignatures()` to **verify the score's validity** using the provided proof.                                                                                |
| **6.** | **Game Contract (Solidity)** | If the score is valid, the contract executes the game logic (e.g., distributing Alice's prize).                                                                                         |

> **Key takeaway for FHEVM v0.9:** Decryption is a **user-driven, off-chain process**. The dApp client is responsible for off-chain decryption, fetching the proof, and relaying the result back on-chain for verification.

**Why this matters:** If your dApp previously relied on the Oracle, you must rewrite your decryption flow. The migration steps below guide you through this change.

## Migration Checklist

Here is a brief, ordered list of the steps required to successfully migrate your project to FHEVM v0.9:

1. **Update Dependencies:** Upgrade all key Zama FHE packages to their **FHEVM v0.9 versions**.
2. **Update Solidity Config:** Replace the removed `SepoliaConfig` with the unified **`ZamaEthereumConfig`**.
3. **Update Solidity Code:** Remove all calls to the discontinued Oracle-based FHE library functions.
4. **Re-compile & Re-deploy:** Due to new FHEVM addresses, all affected contracts must be re-compiled and re-deployed on Sepolia.
5. **Rewrite Public Decryption Logic:** Eliminate reliance on the discontinued Zama Oracle and implement the **self-relaying** workflow using the `@zama-fhe/relayer-sdk` and `FHE.verifySignatures()`.

Follow these steps for a smooth transition to FHEVM v0.9:

### Step 1: Update Core Dependencies

Ensure your project uses the latest versions of the FHEVM development tools.

| Dependency              | Minimum Required Version | Notes                                                                 |
| ----------------------- | ------------------------ | --------------------------------------------------------------------- |
| `@fhevm/solidity`       | `v0.9.1`                 | Contains the updated FHE library contracts.                           |
| `@zama-fhe/relayer-sdk` | `v0.3.0-5`               | **Crucial for v0.9:** Enables the new self-relaying decryption model. |
| `@fhevm/hardhat-plugin` | `v0.3.0-1`               | Latest tooling support for development and deployment.                |

### Step 2: Update Network Configuration in Solidity

The Solidity contracts now use a unified configuration contract defined in `@fhevm/solidity/config/ZamaConfig.sol`.

* **⚠️ Removal:** The `SepoliaConfig` contract is now **removed**.
* **✅ New Standard:** Update your imports and usages to use the new standard **`ZamaEthereumConfig`** contract. This change simplifies future cross-chain compatibility.

The new `ZamaEthereumConfig` abstract contract now dynamically resolves the FHEVM host addresses according to the `block.chainid`.

Replace:

```solidity
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";
```

With:

```solidity
import { ZamaEthereumConfig } from "@fhevm/solidity/config/ZamaConfig.sol";
```

You can read more about [Configuration on the dedicated page](https://docs.zama.org/protocol/solidity-guides/smart-contract/configure).

### Step 3: Update Solidity Code

The Zama public decryption Oracle is discontinued. The following functions are no more available in the FHE Solidity library:

* `FHE.loadRequestedHandles`
* `FHE.requestDecryptionWithoutSavingHandles`
* `FHE.requestDecryption`

### Step 4: Re-compile and Re-deploy Smart Contracts

Due to fundamental changes in the FHEVM implementation and underlying infrastructure:

* **New FHEVM Addresses:** The contract addresses for core FHE components have changed.
* **Action:** You **must** re-compile your entire Solidity codebase and re-deploy all affected contracts to the **Sepolia** network.

### Step 5: Adjust Public Decryption Logic (Crucial Architectural Change)

The most significant change is the discontinuation of the Zama Oracle. This requires substantial adjustments to how your dApp handles decryption on-chain.

| Aspect                 | FHEVM v0.8 (Old Logic)                                                | FHEVM v0.9 (New Logic)                                                               |
| ---------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **Decryption Handler** | **Zama Oracle** actively listens for requests and submits the result. | **dApp Client/User** performs the off-chain decryption (self-relaying).              |
| **Solidity Function**  | Used `FHE.requestDecryption()`.                                       | You will now create custom functions that accept the decrypted value and the proof.  |
| **Client-Side Tool**   | N/A                                                                   | **Use `@zama-fhe/relayer-sdk`** to perform the `publicDecrypt` and obtain the proof. |

> **Action:** Thoroughly review your Solidity code, dApp logic, and backend services. Any code relying on the external Oracle must be rewritten to implement the self-relaying workflow using the `@zama-fhe/relayer-sdk`.

## FHEVM v0.9 Code Examples: Public Decryption Logic

The following code examples illustrate the **new public decryption logic** introduced in v0.9. This new workflow uses the combination of:

* **On-chain public decyption permission** via `FHE.makePubliclyDecryptable`
* **Off-chain decryption** via `publicDecrypt` using the `@zama-fhe/relayer-sdk` or the FHEVM Hardhat Plugin
* **On-chain signature verification** via `FHE.checkSignatures`

#### Code Examples

* [HeadsOrTails](https://github.com/zama-ai/fhevm/blob/release/0.9.x/docs/examples/heads-or-tails.md): Demonstrates the complete public decryption workflow where a cipher text is first marked as decryptable on-chain via `FHE.makePubliclyDecryptable`, and its cleartext value is subsequently verified on-chain using `FHE.checkSignatures` after being fetched off-chain via `publicDecrypt`.
* [HighestDieRoll](https://github.com/zama-ai/fhevm/blob/release/0.9.x/docs/examples/highest-die-roll.md): Extends the public decryption workflow to a multi-input scenario, demonstrating how the on-chain `FHE.checkSignatures` function ensures the authenticity of multiple cleartext values derived from multiple encrypted on-chain cypher texts.


# How to Transform Your Smart Contract into a FHEVM Smart Contract?

This short guide will walk you through converting a standard Solidity contract into one that leverages Fully Homomorphic Encryption (FHE) using FHEVM. This approach lets you develop your contract logic as usual, then adapt it to support encrypted computation for privacy.

For this guide, we will focus on a voting contract example.

***

## 1. Start with a Standard Solidity Contract

Begin by writing your voting contract in Solidity as you normally would. Focus on implementing the core logic and functionality.

```solidity
// Standard Solidity voting contract example
pragma solidity ^0.8.0;

contract SimpleVoting {
    mapping(address => bool) public hasVoted;
    uint64 public yesVotes;
    uint64 public noVotes;
    uint256 public voteDeadline;

    function vote(bool support) public {
        require(block.timestamp <= voteDeadline, "Too late to vote");
        require(!hasVoted[msg.sender], "Already voted");
        hasVoted[msg.sender] = true;

        if (support) {
            yesVotes += 1;
        } else {
            noVotes += 1;
        }
    }

    function getResults() public view returns (uint64, uint64) {
        return (yesVotes, noVotes);
    }
}
```

***

## 2. Identify Sensitive Data and Operations

Review your contract and determine which variables, functions, or computations require privacy. In this example, the vote counts (`yesVotes`, `noVotes`) and individual votes should be encrypted.

***

## 3. Integrate FHEVM and update your business logic accordingly.

Replace standard data types and operations with their FHEVM equivalents for the identified sensitive parts. Use encrypted types and FHEVM library functions to perform computations on encrypted data.

```solidity
pragma solidity ^0.8.0;

import "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedSimpleVoting is ZamaEthereumConfig {
    enum VotingStatus {
        Open,
        DecryptionInProgress,
        ResultsDecrypted
    }
    mapping(address => bool) public hasVoted;

    VotingStatus public status;

    uint64 public decryptedYesVotes;
    uint64 public decryptedNoVotes;

    uint256 public voteDeadline;

    euint64 private encryptedYesVotes;
    euint64 private encryptedNoVotes;

    constructor() {
        encryptedYesVotes = FHE.asEuint64(0);
        encryptedNoVotes = FHE.asEuint64(0);

        FHE.allowThis(encryptedYesVotes);
        FHE.allowThis(encryptedNoVotes);
    }

    function vote(externalEbool support, bytes memory inputProof) public {
        require(block.timestamp <= voteDeadline, "Too late to vote");
        require(!hasVoted[msg.sender], "Already voted");
        hasVoted[msg.sender] = true;
        ebool isSupport = FHE.fromExternal(support, inputProof);
        encryptedYesVotes = FHE.select(isSupport, FHE.add(encryptedYesVotes, 1), encryptedYesVotes);
        encryptedNoVotes = FHE.select(isSupport, encryptedNoVotes, FHE.add(encryptedNoVotes, 1));
        FHE.allowThis(encryptedYesVotes);
        FHE.allowThis(encryptedNoVotes);

    }

    function requestVoteDecryption() public {
        require(block.timestamp > voteDeadline, "Voting is not finished");
        bytes32[] memory cts = new bytes32[](2);
        cts[0] = FHE.toBytes32(encryptedYesVotes);
        cts[1] = FHE.toBytes32(encryptedNoVotes);
        uint256 requestId = FHE.requestDecryption(cts, this.callbackDecryptVotes.selector);
        status = VotingStatus.DecryptionInProgress;
    }

    function callbackDecryptVotes(uint256 requestId, bytes memory cleartexts, bytes memory decryptionProof) public {
        FHE.checkSignatures(requestId, cleartexts, decryptionProof);

        (uint64 yesVotes, uint64 noVotes) = abi.decode(cleartexts, (uint64, uint64));
        decryptedYesVotes = yesVotes;
        decryptedNoVotes = noVotes;
        status = VotingStatus.ResultsDecrypted;
    }

    function getResults() public view returns (uint64, uint64) {
        require(status == VotingStatus.ResultsDecrypted, "Results were not decrypted");
        return (
            decryptedYesVotes,
            decryptedNoVotes
        );
    }
}
```

Adjust your contract’s code to accept and return encrypted data where necessary. This may involve changing function parameters and return types to work with ciphertexts instead of plaintext values, as shown above.

* The `vote` function now has two parameters: `support` and `inputProof`.
* The `getResults` can only be called after the decryption occurred. Otherwise, the decrypted results are not visible to anyone.

However, it is far from being the main change. As this example illustrates, working with FHEVM often requires re-architecting the original logic to support privacy.

In the updated code, the logic becomes async; results are hidden until a request (to the oracle) explicitely has to be made to decrypt publically the vote results.

## Conclusion

As this short guide showed, integrating with FHEVM not only requires integration with the FHEVM stack, it also requires refactoring your business logic to support mechanism to swift between encrypted and non-encrypted components of the logic.
